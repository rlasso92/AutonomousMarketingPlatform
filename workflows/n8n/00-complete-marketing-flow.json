{
  "name": "Complete Marketing Flow - Integrated",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "marketing-request",
        "responseMode": "immediately",
        "options": {}
      },
      "id": "66a2c93d-bd58-46b0-a0e5-6d0ee02f48a2",
      "name": "Webhook - Receive Request",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1408,
        -32
      ],
      "webhookId": "complete-marketing-flow-webhook"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "tenantId",
              "name": "tenantId",
              "value": "={{ $json.body?.body?.tenantId ?? $json.body?.tenantId ?? $json.tenantId }}",
              "type": "string"
            },
            {
              "id": "userId",
              "name": "userId",
              "value": "={{ $json.body?.body?.userId ?? $json.body?.userId ?? $json.userId }}",
              "type": "string"
            },
            {
              "id": "campaignId",
              "name": "campaignId",
              "value": "={{ $json.body?.body?.campaignId ?? $json.body?.campaignId ?? $json.campaignId }}",
              "type": "string"
            },
            {
              "id": "instruction",
              "name": "instruction",
              "value": "={{ $json.body?.body?.instruction ?? $json.body?.instruction ?? $json.instruction }}",
              "type": "string"
            },
            {
              "id": "channels",
              "name": "channels",
              "value": "={{ $json.body?.body?.channels ?? $json.body?.channels ?? $json.channels ?? [] }}",
              "type": "array"
            },
            {
              "id": "channelsNormalized",
              "name": "channelsNormalized",
              "value": "={{ Array.isArray($json.body?.body?.channels) ? $json.body.body.channels : (Array.isArray($json.body?.channels) ? $json.body.channels : (Array.isArray($json.channels) ? $json.channels : [])) }}",
              "type": "array"
            },
            {
              "id": "assets",
              "name": "assets",
              "value": "={{ $json.body?.body?.assets ?? $json.body?.assets ?? $json.assets ?? [] }}",
              "type": "array"
            },
            {
              "id": "requiresApproval",
              "name": "requiresApproval",
              "value": "={{ $json.body?.body?.requiresApproval ?? $json.body?.requiresApproval ?? $json.requiresApproval ?? true }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "id": "e6851c86-d284-4c2c-a0b3-0e7764e66dd2",
      "name": "Normalize Payload",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -1200,
        -32
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $json.tenantId }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              },
              "id": "ca6cd3c9-5e23-4396-ba56-f610c1b7b9d3"
            },
            {
              "leftValue": "={{ $json.userId }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              },
              "id": "712a596a-fa3f-453c-a31c-3cbfa3f4b5c2"
            },
            {
              "leftValue": "={{ $json.instruction }}",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              },
              "id": "18e14f1d-edb7-48cc-bbb8-9a7b963eb8c6"
            },
            {
              "leftValue": "={{ Number(($json.channelsNormalized ?? $json.channels ?? []).length) }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "larger"
              },
              "id": "98b9bf66-4d67-46c4-bde8-707ba155a496"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "4650b95a-16d7-4502-aec2-42f075cc9db3",
      "name": "Validate Required Fields",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1008,
        -32
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "validatedData",
              "name": "validatedData",
              "value": "={{ (() => { function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); } return { tenantId: $json.tenantId, userId: $json.userId, campaignId: $json.campaignId, instruction: $json.instruction, channels: $json.channelsNormalized, assets: $json.assets, requiresApproval: $json.requiresApproval, receivedAt: new Date().toISOString(), requestId: generateUUID() }; })() }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "id": "433118cd-d8f1-4edd-b9e0-25400622bc70",
      "name": "Set Validated Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -800,
        -32
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "body",
              "name": "body",
              "value": "={{ { body: { tenantId: $json.body?.body?.tenantId ?? $json.body?.tenantId ?? $json.tenantId, userId: $json.body?.body?.userId ?? $json.body?.userId ?? $json.userId, campaignId: $json.body?.body?.campaignId ?? $json.body?.campaignId ?? $json.campaignId, instruction: $json.body?.body?.instruction ?? $json.body?.instruction ?? $json.instruction, channels: $json.body?.body?.channels ?? $json.body?.channels ?? $json.channelsNormalized, assets: $json.body?.body?.assets ?? $json.body?.assets ?? $json.assets, requiresApproval: $json.body?.body?.requiresApproval ?? $json.body?.requiresApproval ?? $json.requiresApproval } } }}",
              "type": "object"
            }
          ]
        },
        "options": {}
      },
      "id": "74742315-708d-4b6a-add8-4d3e5f503d01",
      "name": "Set Cognitive Engine Version",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -608,
        -32
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/ConsentsApi/check",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{$json.body.body.tenantId}}"
            },
            {
              "name": "userId",
              "value": "={{$json.body.body.userId}}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "09cd3071-f069-43ff-b695-97568edc481f",
      "name": "HTTP Request - Check Consents",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -400,
        -32
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "aiConsent",
              "name": "aiConsent",
              "value": "={{ ($json.AiConsent ?? $json.aiConsent ?? $json.data?.AiConsent ?? $json.data?.aiConsent ?? false) === true }}",
              "type": "boolean"
            },
            {
              "id": "publishingConsent",
              "name": "publishingConsent",
              "value": "={{ ($json.PublishingConsent ?? $json.publishingConsent ?? $json.data?.PublishingConsent ?? $json.data?.publishingConsent ?? false) === true }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "id": "bc5ed422-af73-4491-9e45-2e05c6c11d8e",
      "name": "Normalize Consents",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -192,
        -32
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.aiConsent === true && $json.publishingConsent === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "2b093b16-0e1a-4af7-8aab-3c5bbd48414e",
      "name": "Validate Consents",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1296,
        416
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/Memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}\n"
            },
            {
              "name": "userId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.userId }}\n"
            },
            {
              "name": "campaignId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.campaignId }}\n"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "b94419b3-b956-4aca-afe1-ab38a2e64afd",
      "name": "HTTP Request - Load Marketing Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -1088,
        416
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "preferences",
              "name": "preferences",
              "value": "={{ $json.preferences ?? $json.Preferences ?? {} }}",
              "type": "object"
            },
            {
              "id": "learnings",
              "name": "learnings",
              "value": "={{ $json.learnings ?? $json.Learnings ?? {} }}",
              "type": "object"
            },
            {
              "id": "restrictions",
              "name": "restrictions",
              "value": "={{ $json.restrictions ?? $json.Restrictions ?? [] }}",
              "type": "array"
            },
            {
              "id": "tenantId",
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}",
              "type": "string"
            },
            {
              "id": "userId",
              "name": "userId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.userId }}",
              "type": "string"
            },
            {
              "id": "campaignId",
              "name": "campaignId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.campaignId }}",
              "type": "string"
            },
            {
              "id": "instruction",
              "name": "instruction",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.instruction }}",
              "type": "string"
            },
            {
              "id": "channels",
              "name": "channels",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.channels }}",
              "type": "array"
            },
            {
              "id": "assets",
              "name": "assets",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.assets }}",
              "type": "array"
            },
            {
              "id": "requiresApproval",
              "name": "requiresApproval",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.requiresApproval }}",
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "id": "3debb5bc-f40c-4405-8748-b2044da83728",
      "name": "Normalize Memory",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3,
      "position": [
        -896,
        416
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/Memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Preference"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "305fa9ec-80a2-4b56-939c-086191e9a513",
      "name": "HTTP Request - Load Preference Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -624,
        256
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/Memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Learning"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "75d44594-b55f-4a6d-8d45-4e449088e6e0",
      "name": "HTTP Request - Load Performance Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -544,
        528
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/Memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Pattern"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "3f43c3bd-0181-499a-910f-8aa93fdb74b5",
      "name": "HTTP Request - Load Pattern Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -560,
        864
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}"
            },
            {
              "name": "orderBy",
              "value": "cognitiveVersion"
            },
            {
              "name": "limit",
              "value": "1"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "615ff253-30db-47e0-a69b-2424231eac39",
      "name": "HTTP Request - Get Last Cognitive Version",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -592,
        1136
      ]
    },
    {
      "parameters": {
        "jsCode": "// Función helper para acceder a nodos de forma segura\nfunction safeGetNodeData(nodeName) {\n  try {\n    const node = $(nodeName);\n    return node?.item?.json || {};\n  } catch (e) {\n    return {};\n  }\n}\n\n// Consolidar las 4 memorias avanzadas\nconst preferenceMemory = safeGetNodeData('HTTP Request - Load Preference Memory');\nconst performanceMemory = safeGetNodeData('HTTP Request - Load Performance Memory');\nconst constraintMemory = safeGetNodeData('HTTP Request - Load Constraint Memory');\nconst patternMemoryData = safeGetNodeData('HTTP Request - Load Pattern Memory');\nconst baseData = safeGetNodeData('Normalize Memory');\n\n// Obtener lastCognitiveVersion de HTTP Request - Get Last Cognitive Version\nconst lastCognitiveVersionResponse = safeGetNodeData('HTTP Request - Get Last Cognitive Version');\nconst lastPack = Array.isArray(lastCognitiveVersionResponse) ? \n  (lastCognitiveVersionResponse[0] || {}) : \n  (lastCognitiveVersionResponse.data?.[0] || lastCognitiveVersionResponse);\nconst lastCognitiveVersion = lastPack?.cognitiveVersion ?? \n  (lastPack?.metadata ? (JSON.parse(lastPack.metadata)?.cognitiveVersion ?? null) : null) ?? 1;\n\n// Extraer patrones fallidos y exitosos de PatternMemory\n// Los patrones vienen como memorias individuales, necesitamos parsearlas\n// Puede venir como array directo, en data, o en learningsList\nconst patternMemories = Array.isArray(patternMemoryData) ? patternMemoryData : \n  (patternMemoryData.data ? patternMemoryData.data : \n   (patternMemoryData.learningsList ? patternMemoryData.learningsList : []));\nconst failedPatterns = [];\nconst successfulPatterns = [];\n\n// BLOQUEO TEMPORAL: Identificar patrones fallidos repetidamente\n// FASE 3: Soporte para severity/blockStatus determinístico\nconst patternFailureCount = {};\nconst blockedPatterns = [];\nconst patternTimestamps = {};\n\n// Función determinística para calcular días desde timestamp\nfunction daysSinceTimestamp(timestamp, referenceTimestamp) {\n  if (!timestamp || !referenceTimestamp) return 999; // Si no hay timestamp, asumir muy antiguo\n  try {\n    const ts = new Date(timestamp).getTime();\n    const ref = new Date(referenceTimestamp).getTime();\n    if (isNaN(ts) || isNaN(ref)) return 999;\n    return Math.round(((ref - ts) / (1000 * 60 * 60 * 24)) * 10000) / 10000; // Redondear a 4 decimales\n  } catch (e) {\n    return 999;\n  }\n}\n\n// Obtener timestamp de referencia determinístico (del validatedData si existe)\nconst validatedDataNode = safeGetNodeData('Set Validated Data');\nconst validatedData = validatedDataNode?.validatedData || {};\nconst referenceTimestamp = validatedData.receivedAt || new Date().toISOString();\n\npatternMemories.forEach(memory => {\n  try {\n    const content = typeof memory.content === 'string' ? JSON.parse(memory.content) : memory.content;\n    const pattern = content.pattern || JSON.stringify(content);\n    \n    if (content.result === 'negative' || (content.penalty && content.penalty < 0) || content.result === 'override_result') {\n      // Contar fallos por patrón\n      patternFailureCount[pattern] = (patternFailureCount[pattern] || 0) + 1;\n      const memoryTimestamp = content.timestamp || content.context?.evaluationTime || referenceTimestamp;\n      patternTimestamps[pattern] = memoryTimestamp;\n      \n      // Extraer severity si existe (de Fase 3)\n      const severity = content.severity || 'moderate'; // Default si no existe\n      const penalty = Math.round((content.penalty || -0.2) * 10000) / 10000; // Redondear a 4 decimales\n      \n      // Calcular días desde fallo (determinístico)\n      const daysSinceFailure = daysSinceTimestamp(memoryTimestamp, referenceTimestamp);\n      \n      // Si un patrón falla 3+ veces, bloquearlo temporalmente (30 días)\n      if (patternFailureCount[pattern] >= 3 && daysSinceFailure < 30) {\n        blockedPatterns.push(pattern);\n      }\n      \n      failedPatterns.push({ \n        pattern: pattern, \n        failureCount: patternFailureCount[pattern], \n        penalty: penalty,\n        severity: severity,\n        timestamp: memoryTimestamp,\n        daysSinceFailure: daysSinceFailure\n      });\n    } else if (content.result === 'positive' || (content.penalty && content.penalty > 0)) {\n      const penalty = Math.round((content.penalty || 0.1) * 10000) / 10000; // Redondear a 4 decimales\n      successfulPatterns.push({ pattern: pattern, penalty: penalty });\n    }\n  } catch (e) {\n    // Ignorar errores de parsing\n  }\n});\n\n// Extraer datos estructurados de cada tipo de memoria\n// Las APIs devuelven: { preferences: {...}, learnings: {...}, restrictions: [...] }\n// baseData viene de HTTP Request - Load Marketing Memory que devuelve la misma estructura\nconst advancedMemory = {\n  preferenceMemory: {\n    preferredTone: preferenceMemory.preferences?.preferredTone || baseData.preferences?.preferredTone || 'profesional',\n    preferredFormats: preferenceMemory.preferences?.preferredFormats || baseData.preferences?.preferredFormats || [],\n    preferredChannels: preferenceMemory.preferences?.preferredChannels || baseData.preferences?.preferredChannels || [],\n    dislikedFormats: preferenceMemory.preferences?.dislikedFormats || baseData.preferences?.dislikedFormats || [],\n    stylePreferences: preferenceMemory.preferences?.stylePreferences || baseData.preferences?.stylePreferences || {}\n  },\n  performanceMemory: {\n    bestPerformingChannels: performanceMemory.learnings?.bestPerformingChannels || baseData.learnings?.bestPerformingChannels || [],\n    channelKPIs: performanceMemory.learnings?.channelKPIs || baseData.learnings?.channelKPIs || {},\n    bestTimes: performanceMemory.learnings?.bestTimes || baseData.learnings?.bestTimes || [],\n    bestDays: performanceMemory.learnings?.bestDays || baseData.learnings?.bestDays || [],\n    avgCTR: performanceMemory.learnings?.avgCTR || baseData.learnings?.avgCTR || 0,\n    avgEngagement: performanceMemory.learnings?.avgEngagement || baseData.learnings?.avgEngagement || 0,\n    topPerformers: performanceMemory.learnings?.topPerformers || baseData.learnings?.topPerformers || []\n  },\n  constraintMemory: {\n    restrictions: constraintMemory.restrictions || baseData.restrictions || [],\n    prohibitedChannels: (constraintMemory.restrictions || baseData.restrictions || []).filter(r => typeof r === 'string' && (r.includes('channel') || r.includes('prohibited'))),\n    legalConstraints: (constraintMemory.restrictions || baseData.restrictions || []).filter(r => typeof r === 'string' && (r.includes('legal') || r.includes('compliance'))),\n    brandConstraints: (constraintMemory.restrictions || baseData.restrictions || []).filter(r => typeof r === 'string' && (r.includes('brand') || r.includes('guidelines')))\n  },\n  patternMemory: {\n    successfulPatterns: successfulPatterns,\n    failedPatterns: failedPatterns,\n    blockedPatterns: blockedPatterns,\n    patternFailureCount: patternFailureCount,\n    patternTimestamps: patternTimestamps,\n    urgencyFormatMapping: patternMemoryData.urgencyFormatMapping || {},\n    channelFormatMapping: patternMemoryData.channelFormatMapping || {},\n    toneChannelMapping: patternMemoryData.toneChannelMapping || {}\n  }\n};\n\n// Calcular confidence weights basados en historial\nconst confidenceWeights = {\n  channel: calculateChannelConfidence(advancedMemory.performanceMemory.bestPerformingChannels, advancedMemory.performanceMemory.channelKPIs),\n  format: calculateFormatConfidence(advancedMemory.patternMemory.urgencyFormatMapping, advancedMemory.performanceMemory.topPerformers),\n  tone: calculateToneConfidence(advancedMemory.performanceMemory.topPerformers, advancedMemory.patternMemory.toneChannelMapping),\n  timing: calculateTimingConfidence(advancedMemory.performanceMemory.bestTimes, advancedMemory.performanceMemory.bestDays)\n};\n\nfunction calculateChannelConfidence(bestChannels, channelKPIs) {\n  const weights = {};\n  if (bestChannels && bestChannels.length > 0) {\n    bestChannels.forEach((channel, index) => {\n      const kpi = channelKPIs[channel] || {};\n      const ctr = kpi.ctr || 0;\n      const engagement = kpi.engagement || 0;\n      \n      // AUTO-AJUSTE: Penaliza canales con bajo rendimiento y refuerza exitosos\n      let baseWeight = 0.5 + (ctr * 10) + (engagement * 5); // CTR y engagement influyen directamente\n      \n      // Penalización fuerte si CTR < 0.5% o engagement < 1%\n      if (ctr < 0.005) baseWeight -= 0.3;\n      if (engagement < 0.01) baseWeight -= 0.2;\n      \n      // Refuerzo si CTR > 2% o engagement > 5%\n      if (ctr > 0.02) baseWeight += 0.2;\n      if (engagement > 0.05) baseWeight += 0.15;\n      \n      // Ajuste por posición (los primeros tienen más peso)\n      baseWeight -= (index * 0.05);\n      \n      weights[channel] = Math.max(0.1, Math.min(0.9, baseWeight));\n    });\n  }\n  return weights;\n}\n\nfunction calculateFormatConfidence(urgencyFormatMapping, topPerformers) {\n  const weights = {};\n  \n  // AUTO-AJUSTE: Refuerza formatos exitosos y penaliza fallidos\n  if (urgencyFormatMapping && Object.keys(urgencyFormatMapping).length > 0) {\n    Object.entries(urgencyFormatMapping).forEach(([urgency, format]) => {\n      // Si está en el mapeo, es porque ha sido exitoso\n      weights[`${urgency}_${format}`] = 0.75; // Aumentado de 0.7 a 0.75\n    });\n  }\n  \n  if (topPerformers && topPerformers.length > 0) {\n    topPerformers.forEach((performer, index) => {\n      if (performer.format) {\n        // Los top performers refuerzan más\n        const boost = 0.15 - (index * 0.02); // Más boost para los primeros\n        weights[performer.format] = (weights[performer.format] || 0.5) + boost;\n      }\n    });\n  }\n  \n  // Normalizar todos los pesos\n  Object.keys(weights).forEach(key => {\n    weights[key] = Math.max(0.1, Math.min(0.9, weights[key]));\n  });\n  \n  return weights;\n}\n\nfunction calculateToneConfidence(topPerformers, toneChannelMapping) {\n  const weights = {};\n  \n  // AUTO-AJUSTE: Refuerza tonos con alto engagement y penaliza los de bajo rendimiento\n  if (topPerformers && topPerformers.length > 0) {\n    topPerformers.forEach((performer, index) => {\n      if (performer.tone) {\n        // Más refuerzo para los primeros (mejores performers)\n        const boost = 0.12 - (index * 0.015);\n        weights[performer.tone] = (weights[performer.tone] || 0.5) + boost;\n      }\n    });\n  }\n  \n  if (toneChannelMapping && Object.keys(toneChannelMapping).length > 0) {\n    Object.entries(toneChannelMapping).forEach(([tone, channels]) => {\n      if (Array.isArray(channels) && channels.length > 0) {\n        // Más canales = más refuerzo\n        const boost = 0.15 + (channels.length * 0.02);\n        weights[tone] = (weights[tone] || 0.5) + boost;\n      }\n    });\n  }\n  \n  // Normalizar todos los pesos\n  Object.keys(weights).forEach(key => {\n    weights[key] = Math.max(0.1, Math.min(0.9, weights[key]));\n  });\n  \n  return weights;\n}\n\nfunction calculateTimingConfidence(bestTimes, bestDays) {\n  const weights = { times: {}, days: {} };\n  if (bestTimes && bestTimes.length > 0) {\n    bestTimes.forEach(time => {\n      weights.times[time] = 0.7;\n    });\n  }\n  if (bestDays && bestDays.length > 0) {\n    bestDays.forEach(day => {\n      weights.days[day] = 0.7;\n    });\n  }\n  return weights;\n}\n\n// AUTO-AJUSTE: Aplicar penalizaciones automáticas a patrones fallidos\n// BLOQUEO TEMPORAL: Excluir patrones bloqueados\nconst avoidPatterns = failedPatterns\n  .filter(pattern => {\n    const patternStr = typeof pattern === 'object' ? pattern.pattern : pattern;\n    return !blockedPatterns.includes(patternStr);\n  })\n  .map(pattern => {\n    // Si el patrón tiene penalización negativa, se evita más\n    if (typeof pattern === 'object' && pattern.penalty && pattern.penalty < 0) {\n      return pattern.pattern || JSON.stringify(pattern);\n    }\n    return typeof pattern === 'string' ? pattern : (pattern.pattern || JSON.stringify(pattern));\n  });\r\n\r\nreturn {\n  ...baseData,\n  advancedMemory: advancedMemory,\n  confidenceWeights: confidenceWeights,\n  learnedBestChannels: advancedMemory.performanceMemory.bestPerformingChannels || [],\n  avoidPatterns: avoidPatterns,\n  preferredFormats: advancedMemory.preferenceMemory.preferredFormats || [],\n  successfulPatterns: successfulPatterns,\n  lastCognitiveVersion: lastCognitiveVersion\n};"
      },
      "id": "3e4d1f10-46ca-489c-a59e-064759e69dd5",
      "name": "Consolidate Advanced Memory",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -352,
        624
      ]
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "complete",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "prompt": "={{ (() => { const instruction = $json.instruction || 'No especificada'; const preferences = $json.preferences || $json.advancedMemory?.preferenceMemory || {}; const learnings = $json.learnings || $json.advancedMemory?.performanceMemory || {}; const restrictions = $json.restrictions || $json.advancedMemory?.constraintMemory?.restrictions || []; const channels = Array.isArray($json.channels) ? $json.channels : []; const systemPrompt = 'Eres un experto analista de marketing cognitivo. Tu tarea es analizar instrucciones de marketing y generar un análisis estructurado. IMPORTANTE: DEBES responder ÚNICAMENTE con un JSON válido, sin texto adicional antes o después, sin markdown, sin explicaciones, sin comentarios. El JSON debe comenzar con { y terminar con }. El JSON debe tener exactamente esta estructura:\\n\\n{\\n  \\\"objective\\\": \\\"string - objetivo principal de la campaña\\\",\\n  \\\"tone\\\": \\\"string - tono recomendado (profesional, casual, formal, amigable)\\\",\\n  \\\"urgency\\\": \\\"string - urgencia (low, medium, high)\\\",\\n  \\\"contentType\\\": \\\"string - tipo de contenido (post, story, reel, video, carousel)\\\",\\n  \\\"targetAudience\\\": \\\"string - audiencia objetivo\\\",\\n  \\\"keyMessages\\\": [\\\"string\\\"],\\n  \\\"hashtags\\\": [\\\"string\\\"],\\n  \\\"channels\\\": [\\\"string\\\"]\\n}\\n\\nNO agregues texto antes o después del JSON. NO uses markdown. Responde SOLO el JSON.'; const userPrompt = 'Analiza la siguiente instrucción de marketing y genera un análisis estructurado:\\n\\n## Instrucción del Usuario:\\n' + instruction + '\\n\\n## Contexto de Memoria:\\n### Preferencias:\\n- Tono preferido: ' + (preferences.preferredTone || 'No especificado') + '\\n- Formatos preferidos: ' + (Array.isArray(preferences.preferredFormats) ? preferences.preferredFormats.join(', ') : 'No especificados') + '\\n- Canales preferidos: ' + (Array.isArray(preferences.preferredChannels) ? preferences.preferredChannels.join(', ') : 'No especificados') + '\\n- Formatos a evitar: ' + (Array.isArray(preferences.dislikedFormats) ? preferences.dislikedFormats.join(', ') : 'Ninguno') + '\\n\\n### Aprendizajes de Rendimiento:\\n- Mejores canales: ' + (Array.isArray(learnings.bestPerformingChannels) ? learnings.bestPerformingChannels.join(', ') : 'No especificados') + '\\n- CTR promedio: ' + (learnings.avgCTR || 0) + '\\n- Engagement promedio: ' + (learnings.avgEngagement || 0) + '\\n\\n### Restricciones:\\n' + (Array.isArray(restrictions) && restrictions.length > 0 ? restrictions.map(r => '- ' + (typeof r === 'string' ? r : JSON.stringify(r))).join('\\n') : '- Ninguna') + '\\n\\n### Canales Solicitados:\\n' + (channels.length > 0 ? channels.join(', ') : 'No especificados') + '\\n\\nResponde SOLO con el JSON del análisis, sin texto adicional.'; return systemPrompt + '\\n\\nUsuario: ' + userPrompt; })() }}",
        "options": {
          "temperature": 0.7,
          "maxTokens": 2000
        },
        "authentication": "openAiApi"
      },
      "id": "9d7047f4-d12d-4efb-8b27-073138323cc0",
      "name": "OpenAI - Analyze Instruction (Cognitive)",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        128,
        1136
      ],
      "credentials": {
        "openAiApi": {
          "id": "wMYaihEIRr9sMMbk",
          "name": "OpenAi account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI (API Completions - resource: text)\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  try {\n    const response = item.json || {};\n    let analysis = {};\n    let errorMessage = '';\n    let rawContent = '';\n    \n    try {\n      // API Completions devuelve: response.choices[0].text (no .message.content)\n      rawContent = response.choices?.[0]?.text || \n                   response.choices?.[0]?.message?.content || \n                   response.text || \n                   response.message?.content || \n                   response.content || \n                   (typeof response === 'string' ? response : '') ||\n                   '';\n      \n      if (!rawContent || rawContent.trim() === '') {\n        errorMessage = 'OpenAI no devolvió contenido';\n        throw new Error('Empty response from OpenAI');\n      }\n      \n      let content = rawContent.trim();\n      if (content.startsWith('```json')) {\n        content = content.replace(/^```json\\s*/g, '').replace(/\\s*```$/g, '');\n      } else if (content.startsWith('```')) {\n        content = content.replace(/^```\\s*/g, '').replace(/\\s*```$/g, '');\n      }\n      content = content.trim();\n      analysis = JSON.parse(content);\n    } catch (error) {\n      try {\n        const jsonMatch = rawContent.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch && jsonMatch[0]) {\n          analysis = JSON.parse(jsonMatch[0]);\n        } else {\n          errorMessage = 'No se pudo extraer JSON: ' + error.message;\n          throw new Error('No JSON found');\n        }\n      } catch (parseError) {\n        errorMessage = 'Error al parsear: ' + error.message;\n        analysis = {\n          objective: 'Error al analizar',\n          tone: 'profesional',\n          urgency: 'medium',\n          contentType: 'post',\n          targetAudience: '',\n          keyMessages: [],\n          hashtags: [],\n          channels: []\n        };\n      }\n    }\n    \n    // Obtener datos del nodo anterior de forma segura\n    let normalizeMemoryData = {};\n    let consolidateMemoryData = {};\n    try {\n      const normalizeNode = $('Normalize Memory');\n      if (normalizeNode && normalizeNode.item) {\n        normalizeMemoryData = normalizeNode.item.json || {};\n      }\n    } catch (e) {}\n    \n    try {\n      const consolidateNode = $('Consolidate Advanced Memory');\n      if (consolidateNode && consolidateNode.item) {\n        consolidateMemoryData = consolidateNode.item.json || {};\n      }\n    } catch (e) {}\n    \n    const memory = normalizeMemoryData.memory || {};\n    const result = {\n      objective: analysis.objective || 'No especificado',\n      tone: analysis.tone || memory.preferredTone || 'profesional',\n      urgency: analysis.urgency || 'medium',\n      contentType: analysis.contentType || 'post',\n      targetAudience: analysis.targetAudience || '',\n      keyMessages: Array.isArray(analysis.keyMessages) ? analysis.keyMessages : [],\n      hashtags: Array.isArray(analysis.hashtags) ? analysis.hashtags : [],\n      channels: Array.isArray(analysis.channels) ? analysis.channels : (normalizeMemoryData.channels || []),\n      originalInstruction: normalizeMemoryData.instruction || consolidateMemoryData.instruction || '',\n      analyzedAt: new Date().toISOString(),\n      tenantId: normalizeMemoryData.tenantId || '',\n      userId: normalizeMemoryData.userId || '',\n      errorMessage: errorMessage || null\n    };\n    \n    results.push({\n      json: {\n        ...normalizeMemoryData,\n        ...consolidateMemoryData,\n        analysis: result\n      }\n    });\n  } catch (e) {\n    results.push({\n      json: {\n        error: e.message,\n        analysis: {\n          objective: 'Error crítico',\n          tone: 'profesional',\n          urgency: 'medium',\n          contentType: 'post',\n          targetAudience: '',\n          keyMessages: [],\n          hashtags: [],\n          channels: []\n        }\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "65afbd0b-12da-45ea-a302-8a3e2939522d",
      "name": "Parse Analysis",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        1200
      ]
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "complete",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "prompt": "={{ (() => { const analysis = $json.analysis || {}; const advancedMemory = $json.advancedMemory || {}; const channels = Array.isArray($json.channels) ? $json.channels : []; const systemPrompt = 'Eres un experto estratega de marketing. Tu tarea es generar estrategias de marketing estructuradas. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\\n\\n{\\n  \\\"mainMessage\\\": \\\"string - mensaje principal de la campaña\\\",\\n  \\\"cta\\\": \\\"string - call to action\\\",\\n  \\\"recommendedFormat\\\": \\\"string - formato recomendado (post, story, reel, video, carousel)\\\",\\n  \\\"suggestedSchedule\\\": {\\n    \\\"bestDays\\\": [\\\"string\\\"],\\n    \\\"bestTimes\\\": [\\\"string\\\"],\\n    \\\"timezone\\\": \\\"string\\\"\\n  },\\n  \\\"contentStructure\\\": {\\n    \\\"headline\\\": \\\"string\\\",\\n    \\\"body\\\": \\\"string\\\",\\n    \\\"hashtags\\\": [\\\"string\\\"],\\n    \\\"mentions\\\": [\\\"string\\\"]\\n  },\\n  \\\"channels\\\": [\\\"string\\\"],\\n  \\\"tone\\\": \\\"string - tono (profesional, casual, formal, amigable)\\\",\\n  \\\"targetAudience\\\": \\\"string - audiencia objetivo\\\",\\n  \\\"keyPoints\\\": [\\\"string\\\"]\\n}'; const userPrompt = 'Genera una estrategia de marketing basada en el siguiente análisis:\\n\\n## Análisis:\\n' + JSON.stringify(analysis, null, 2) + '\\n\\n## Memoria Avanzada:\\n' + JSON.stringify(advancedMemory, null, 2) + '\\n\\n## Canales Solicitados:\\n' + (channels.length > 0 ? channels.join(', ') : 'No especificados') + '\\n\\nResponde SOLO con el JSON de la estrategia, sin texto adicional.'; return systemPrompt + '\\n\\nUsuario: ' + userPrompt; })() }}",
        "options": {
          "temperature": 0.7,
          "maxTokens": 2000
        },
        "authentication": "openAiApi"
      },
      "id": "41c01cb3-c6e8-4627-ac7a-49efb69bca45",
      "name": "OpenAI - Generate Strategy",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        -272,
        208
      ],
      "credentials": {
        "openAiApi": {
          "id": "wMYaihEIRr9sMMbk",
          "name": "OpenAi account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI (API Completions - resource: text)\nconst response = $input.item.json;\nlet strategy = {};\n\ntry {\n  // API Completions devuelve: response.choices[0].text\n  let content = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  strategy = JSON.parse(content);\n} catch (error) {\n  try {\n    const rawContent = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n    const jsonMatch = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      strategy = JSON.parse(jsonMatch[0]);\n    } else {\n      const analysis = $('Parse Analysis').item.json.analysis || {};\n      strategy = {\n        mainMessage: analysis.objective || 'Mensaje principal de la campaña',\n        cta: 'Descubre más',\n        recommendedFormat: analysis.contentType || 'post',\n        suggestedSchedule: { bestDays: ['lunes', 'miércoles', 'viernes'], bestTimes: ['09:00', '13:00', '18:00'], timezone: 'UTC' },\n        contentStructure: { headline: analysis.objective || '', body: '', hashtags: analysis.hashtags || [], mentions: [] },\n        channels: analysis.channels || [],\n        tone: analysis.tone || 'profesional',\n        targetAudience: analysis.targetAudience || '',\n        keyPoints: analysis.keyMessages || []\n      };\n    }\n  } catch (parseError) {\n    const analysis = $('Parse Analysis').item.json.analysis || {};\n    strategy = {\n      mainMessage: 'Estrategia de marketing',\n      cta: 'Descubre más',\n      recommendedFormat: 'post',\n      suggestedSchedule: { bestDays: ['lunes', 'miércoles', 'viernes'], bestTimes: ['09:00', '13:00', '18:00'], timezone: 'UTC' },\n      contentStructure: { headline: '', body: '', hashtags: [], mentions: [] },\n      channels: [],\n      tone: 'profesional',\n      targetAudience: '',\n      keyPoints: []\n    };\n  }\n}\n\nconst finalStrategy = {\n  mainMessage: strategy.mainMessage || 'Mensaje principal de la campaña',\n  cta: strategy.cta || 'Descubre más',\n  recommendedFormat: strategy.recommendedFormat || 'post',\n  suggestedSchedule: {\n    bestDays: Array.isArray(strategy.suggestedSchedule?.bestDays) ? strategy.suggestedSchedule.bestDays : ['lunes', 'miércoles', 'viernes'],\n    bestTimes: Array.isArray(strategy.suggestedSchedule?.bestTimes) ? strategy.suggestedSchedule.bestTimes : ['09:00', '13:00', '18:00'],\n    timezone: strategy.suggestedSchedule?.timezone || 'UTC'\n  },\n  contentStructure: {\n    headline: strategy.contentStructure?.headline || '',\n    body: strategy.contentStructure?.body || '',\n    hashtags: Array.isArray(strategy.contentStructure?.hashtags) ? strategy.contentStructure.hashtags : [],\n    mentions: Array.isArray(strategy.contentStructure?.mentions) ? strategy.contentStructure.mentions : []\n  },\n  channels: Array.isArray(strategy.channels) ? strategy.channels : ($('Parse Analysis').item.json.channels || []),\n  tone: strategy.tone || 'profesional',\n  targetAudience: strategy.targetAudience || '',\n  keyPoints: Array.isArray(strategy.keyPoints) ? strategy.keyPoints : []\n};\n\nconst metadata = {\n  tenantId: $('Parse Analysis').item.json.tenantId || '',\n  generatedAt: new Date().toISOString(),\n  basedOnAnalysis: $('Parse Analysis').item.json.analysis || {},\n  basedOnMemory: $('Parse Analysis').item.json.memory || {}\n};\n\nreturn {\n  ...$('Parse Analysis').item.json,\n  strategy: { ...finalStrategy, metadata }\n};"
      },
      "id": "fd30907c-9608-414c-97b1-ff23710c3ea7",
      "name": "Parse Strategy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        224
      ]
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "complete",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "prompt": "={{ (() => { const strategy = $json.strategy || {}; const analysis = $json.analysis || {}; const advancedMemory = $json.advancedMemory || {}; const systemPrompt = 'Eres un copywriter experto de marketing. Tu tarea es generar copy de marketing estructurado. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\\n\\n{\\n  \\\"shortCopy\\\": \\\"string - copy corto (para stories, tweets)\\\",\\n  \\\"longCopy\\\": \\\"string - copy largo (para posts)\\\",\\n  \\\"hashtags\\\": [\\\"string\\\"],\\n  \\\"variants\\\": {\\n    \\\"variantA\\\": {\\n      \\\"shortCopy\\\": \\\"string\\\",\\n      \\\"longCopy\\\": \\\"string\\\",\\n      \\\"hashtags\\\": [\\\"string\\\"]\\n    },\\n    \\\"variantB\\\": {\\n      \\\"shortCopy\\\": \\\"string\\\",\\n      \\\"longCopy\\\": \\\"string\\\",\\n      \\\"hashtags\\\": [\\\"string\\\"]\\n    }\\n  },\\n  \\\"headline\\\": \\\"string - titular\\\",\\n  \\\"cta\\\": \\\"string - call to action\\\",\\n  \\\"emojiSuggestions\\\": [\\\"string\\\"],\\n  \\\"mentions\\\": [\\\"string\\\"]\\n}'; const userPrompt = 'Genera copy de marketing basado en la siguiente estrategia:\\n\\n## Estrategia:\\n' + JSON.stringify(strategy, null, 2) + '\\n\\n## Análisis Original:\\n' + JSON.stringify(analysis, null, 2) + '\\n\\n## Memoria Avanzada:\\n' + JSON.stringify(advancedMemory, null, 2) + '\\n\\nResponde SOLO con el JSON del copy, sin texto adicional.'; return systemPrompt + '\\n\\nUsuario: ' + userPrompt; })() }}",
        "options": {
          "temperature": 0.7,
          "maxTokens": 2000
        },
        "authentication": "openAiApi"
      },
      "id": "7ed55794-0933-4a0e-a155-a36e83bd0f0a",
      "name": "OpenAI - Generate Copy",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        128,
        224
      ],
      "credentials": {
        "openAiApi": {
          "id": "wMYaihEIRr9sMMbk",
          "name": "OpenAi account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI (API Completions - resource: text)\nconst response = $input.item.json;\nlet copyData = {};\n\ntry {\n  // API Completions devuelve: response.choices[0].text\n  let content = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  copyData = JSON.parse(content);\n} catch (error) {\n  try {\n    const rawContent = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n    const jsonMatch = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      copyData = JSON.parse(jsonMatch[0]);\n    } else {\n      const strategy = $('Parse Strategy').item.json.strategy || {};\n      copyData = {\n        shortCopy: strategy.mainMessage || 'Descubre más',\n        longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''),\n        hashtags: strategy.contentStructure?.hashtags || strategy.keyPoints || [],\n        variants: {\n          variantA: { shortCopy: strategy.mainMessage || 'Descubre más', longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''), hashtags: strategy.contentStructure?.hashtags || [] },\n          variantB: { shortCopy: strategy.mainMessage || 'Explora ahora', longCopy: (strategy.contentStructure?.body || strategy.mainMessage || '') + '\\n\\n' + (strategy.cta || ''), hashtags: strategy.contentStructure?.hashtags || [] }\n        },\n        headline: strategy.contentStructure?.headline || strategy.mainMessage || '',\n        cta: strategy.cta || 'Descubre más',\n        emojiSuggestions: [],\n        mentions: strategy.contentStructure?.mentions || []\n      };\n    }\n  } catch (parseError) {\n    const strategy = $('Parse Strategy').item.json.strategy || {};\n    copyData = {\n      shortCopy: 'Copy corto',\n      longCopy: 'Copy largo',\n      hashtags: [],\n      variants: { variantA: { shortCopy: '', longCopy: '', hashtags: [] }, variantB: { shortCopy: '', longCopy: '', hashtags: [] } },\n      headline: '',\n      cta: '',\n      emojiSuggestions: [],\n      mentions: []\n    };\n  }\n}\n\nconst finalCopy = {\n  shortCopy: copyData.shortCopy || 'Copy corto',\n  longCopy: copyData.longCopy || 'Copy largo',\n  hashtags: Array.isArray(copyData.hashtags) ? copyData.hashtags : [],\n  variants: {\n    variantA: {\n      shortCopy: copyData.variants?.variantA?.shortCopy || copyData.shortCopy || 'Variante A - Copy corto',\n      longCopy: copyData.variants?.variantA?.longCopy || copyData.longCopy || 'Variante A - Copy largo',\n      hashtags: Array.isArray(copyData.variants?.variantA?.hashtags) ? copyData.variants.variantA.hashtags : (copyData.hashtags || [])\n    },\n    variantB: {\n      shortCopy: copyData.variants?.variantB?.shortCopy || copyData.shortCopy || 'Variante B - Copy corto',\n      longCopy: copyData.variants?.variantB?.longCopy || copyData.longCopy || 'Variante B - Copy largo',\n      hashtags: Array.isArray(copyData.variants?.variantB?.hashtags) ? copyData.variants.variantB.hashtags : (copyData.hashtags || [])\n    }\n  },\n  headline: copyData.headline || '',\n  cta: copyData.cta || 'Descubre más',\n  emojiSuggestions: Array.isArray(copyData.emojiSuggestions) ? copyData.emojiSuggestions : [],\n  mentions: Array.isArray(copyData.mentions) ? copyData.mentions : []\n};\n\nconst strategy = $('Parse Strategy').item.json.strategy || {};\nconst publishReady = {\n  ...finalCopy,\n  publishFormat: {\n    instagram: {\n      caption: finalCopy.longCopy + '\\n\\n' + finalCopy.hashtags.map(h => '#' + h.replace(/^#/, '')).join(' '),\n      storyText: finalCopy.shortCopy,\n      hashtags: finalCopy.hashtags\n    },\n    facebook: {\n      post: finalCopy.longCopy,\n      hashtags: finalCopy.hashtags\n    },\n    twitter: {\n      tweet: finalCopy.shortCopy,\n      thread: finalCopy.longCopy,\n      hashtags: finalCopy.hashtags\n    }\n  },\n  metadata: {\n    tenantId: $('Parse Strategy').item.json.tenantId || '',\n    generatedAt: new Date().toISOString(),\n    format: strategy.recommendedFormat || 'post',\n    channels: strategy.channels || [],\n    tone: strategy.tone || 'profesional'\n  }\n};\n\nreturn {\n  ...$('Parse Strategy').item.json,\n  copy: publishReady\n};"
      },
      "id": "b1719189-fe77-4808-b33f-19da2097c3c9",
      "name": "Parse Copy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        224
      ]
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "complete",
        "model": "={{ $env.OPENAI_MODEL || 'gpt-4' }}",
        "prompt": "={{ (() => { const strategy = $json.strategy || {}; const copy = $json.copy || {}; const advancedMemory = $json.advancedMemory || {}; const systemPrompt = 'Eres un experto en generación de prompts visuales para marketing. Tu tarea es generar prompts para imágenes y videos. DEBES responder SOLO con un JSON válido, sin texto adicional, sin markdown, sin explicaciones. El JSON debe tener exactamente esta estructura:\\n\\n{\\n  \\\"imagePrompt\\\": \\\"string - prompt detallado para imagen\\\",\\n  \\\"videoPrompt\\\": \\\"string - prompt detallado para video\\\",\\n  \\\"imageStyle\\\": \\\"string - estilo de imagen (professional, vibrant, casual)\\\",\\n  \\\"colorPalette\\\": [\\\"string\\\"],\\n  \\\"mood\\\": \\\"string - mood (professional, casual, energetic)\\\",\\n  \\\"aspectRatio\\\": \\\"string - relación de aspecto (1:1, 16:9, 9:16)\\\",\\n  \\\"technicalSpecs\\\": {\\n    \\\"resolution\\\": \\\"string\\\",\\n    \\\"quality\\\": \\\"string\\\",\\n    \\\"lighting\\\": \\\"string\\\",\\n    \\\"composition\\\": \\\"string\\\"\\n  }\\n}'; const userPrompt = 'Genera prompts visuales basados en la siguiente estrategia y copy:\\n\\n## Estrategia:\\n' + JSON.stringify(strategy, null, 2) + '\\n\\n## Copy:\\n' + JSON.stringify(copy, null, 2) + '\\n\\n## Memoria Avanzada:\\n' + JSON.stringify(advancedMemory, null, 2) + '\\n\\nResponde SOLO con el JSON de los prompts visuales, sin texto adicional.'; return systemPrompt + '\\n\\nUsuario: ' + userPrompt; })() }}",
        "options": {
          "temperature": 0.7,
          "maxTokens": 2000
        },
        "authentication": "openAiApi"
      },
      "id": "b628d22c-13d1-4a41-9a2b-93fcb0a5af63",
      "name": "OpenAI - Generate Visual Prompts",
      "type": "n8n-nodes-base.openAi",
      "typeVersion": 1,
      "position": [
        528,
        224
      ],
      "credentials": {
        "openAiApi": {
          "id": "wMYaihEIRr9sMMbk",
          "name": "OpenAi account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsear la respuesta de OpenAI (API Completions - resource: text)\nconst response = $input.item.json;\nlet visualPrompts = {};\n\ntry {\n  // API Completions devuelve: response.choices[0].text\n  let content = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n  content = content.trim();\n  if (content.startsWith('```json')) {\n    content = content.replace(/```json\\s*/g, '').replace(/```\\s*/g, '');\n  } else if (content.startsWith('```')) {\n    content = content.replace(/```\\s*/g, '');\n  }\n  visualPrompts = JSON.parse(content);\n} catch (error) {\n  try {\n    const rawContent = response.choices?.[0]?.text || response.choices?.[0]?.message?.content || response.text || response.message?.content || '';\n    const jsonMatch = rawContent.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      visualPrompts = JSON.parse(jsonMatch[0]);\n    } else {\n      const strategy = $('Parse Copy').item.json.strategy || {};\n      const copy = $('Parse Copy').item.json.copy || {};\n      const mainMessage = strategy.mainMessage || copy.longCopy || 'Producto de marketing';\n      visualPrompts = {\n        imagePrompt: `High-quality marketing image: ${mainMessage}. Professional photography style, vibrant colors, modern composition, natural lighting, engaging and attractive visual, optimized for social media, ${strategy.tone || 'professional'} tone`,\n        videoPrompt: `Marketing video: ${mainMessage}. Smooth camera movements, dynamic transitions, professional cinematography, vibrant colors, engaging visual storytelling, ${strategy.tone || 'professional'} aesthetic, optimized for social media`,\n        imageStyle: strategy.tone === 'casual' ? 'vibrant' : 'professional',\n        colorPalette: ['vibrant', 'modern'],\n        mood: strategy.tone || 'professional',\n        aspectRatio: strategy.recommendedFormat === 'story' ? '9:16' : strategy.recommendedFormat === 'reel' ? '9:16' : '1:1',\n        technicalSpecs: { resolution: 'high', quality: 'professional', lighting: 'natural', composition: 'balanced' }\n      };\n    }\n  } catch (parseError) {\n    const strategy = $('Parse Copy').item.json.strategy || {};\n    visualPrompts = {\n      imagePrompt: 'High-quality marketing image, professional style, vibrant colors',\n      videoPrompt: 'Marketing video, professional cinematography, engaging visuals',\n      imageStyle: 'professional',\n      colorPalette: [],\n      mood: 'professional',\n      aspectRatio: '1:1',\n      technicalSpecs: { resolution: 'high', quality: 'professional', lighting: 'natural', composition: 'balanced' }\n    };\n  }\n}\n\nconst finalPrompts = {\n  imagePrompt: visualPrompts.imagePrompt || 'High-quality marketing image, professional style',\n  videoPrompt: visualPrompts.videoPrompt || 'Marketing video, professional cinematography',\n  imageStyle: visualPrompts.imageStyle || 'professional',\n  colorPalette: Array.isArray(visualPrompts.colorPalette) ? visualPrompts.colorPalette : [],\n  mood: visualPrompts.mood || 'professional',\n  aspectRatio: visualPrompts.aspectRatio || '1:1',\n  technicalSpecs: {\n    resolution: visualPrompts.technicalSpecs?.resolution || 'high',\n    quality: visualPrompts.technicalSpecs?.quality || 'professional',\n    lighting: visualPrompts.technicalSpecs?.lighting || 'natural',\n    composition: visualPrompts.technicalSpecs?.composition || 'balanced'\n  }\n};\n\nconst strategy = $('Parse Copy').item.json.strategy || {};\nconst metadata = {\n  tenantId: $('Parse Copy').item.json.tenantId || '',\n  generatedAt: new Date().toISOString(),\n  format: strategy.recommendedFormat || 'post',\n  channels: strategy.channels || [],\n  tone: strategy.tone || 'professional'\n};\n\nreturn {\n  ...$('Parse Copy').item.json,\n  visualPrompts: { ...finalPrompts, metadata }\n};"
      },
      "id": "2d0b7b5a-34bc-4fa5-9f45-7fb88d652a54",
      "name": "Parse Visual Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        224
      ]
    },
    {
      "parameters": {
        "jsCode": "// Motor de Decisiones Cognitivo - Calcula confidenceScore y ajusta decisiones\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  try {\n    const components = item.json || {};\nconst strategy = components.strategy || {};\nconst copy = components.copy || {};\nconst visualPrompts = components.visualPrompts || {};\nconst advancedMemory = components.advancedMemory || {};\nconst confidenceWeights = components.confidenceWeights || {};\nconst analysis = components.analysis || {};\n\n// Calcular confidenceScore base (0-1)\nlet confidenceScore = 0.5; // Base\nlet decisionRationale = [];\nlet learningSources = [];\n\n// Factor 1: Canales con mejor performance (30%)\n// AUTO-AJUSTE: Penaliza canales con bajo rendimiento histórico y refuerza los exitosos\nconst selectedChannels = Array.isArray(strategy.channels) ? strategy.channels : [];\nconst performanceMemory = advancedMemory.performanceMemory || {};\nconst channelKPIs = performanceMemory.channelKPIs || {};\n\n// Ajustar confidenceWeights basado en resultados históricos\nconst adjustedChannelWeights = {};\nselectedChannels.forEach(channel => {\n  const baseWeight = confidenceWeights.channel?.[channel.toLowerCase()] || 0.5;\n  const kpi = channelKPIs[channel.toLowerCase()] || {};\n  const ctr = kpi.ctr || 0;\n  const engagement = kpi.engagement || 0;\n  \n  // Ajuste automático: refuerza si tiene buen CTR/engagement, penaliza si no\n  let adjustment = 0;\n  if (ctr > 0.02) adjustment += 0.1; // CTR > 2% es bueno\n  if (ctr < 0.005) adjustment -= 0.15; // CTR < 0.5% es malo\n  if (engagement > 0.05) adjustment += 0.1; // Engagement > 5% es bueno\n  if (engagement < 0.01) adjustment -= 0.15; // Engagement < 1% es malo\n  \n  adjustedChannelWeights[channel.toLowerCase()] = Math.max(0.1, Math.min(0.9, baseWeight + adjustment));\n});\n\nconst channelConfidence = selectedChannels.reduce((acc, channel) => {\n  const weight = adjustedChannelWeights[channel.toLowerCase()] || 0.5;\n  return acc + weight;\n}, 0) / Math.max(selectedChannels.length, 1);\nconfidenceScore += channelConfidence * 0.3;\nif (channelConfidence > 0.6) {\n  decisionRationale.push(`Canales seleccionados tienen alta performance histórica (${(channelConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PerformanceMemory');\n}\n\n// Factor 2: Formato apropiado para urgencia (20%)\nconst urgency = analysis.urgency || 'medium';\nconst format = strategy.recommendedFormat || 'post';\nconst formatKey = `${urgency}_${format}`;\nconst formatConfidence = confidenceWeights.format?.[formatKey] || confidenceWeights.format?.[format] || 0.5;\nconfidenceScore += formatConfidence * 0.2;\nif (formatConfidence > 0.6) {\n  decisionRationale.push(`Formato ${format} es exitoso para urgencia ${urgency} (${(formatConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PatternMemory');\n}\n\n// Factor 3: Tono con mayor engagement (20%)\nconst tone = strategy.tone || 'profesional';\nconst toneConfidence = confidenceWeights.tone?.[tone] || 0.5;\nconfidenceScore += toneConfidence * 0.2;\nif (toneConfidence > 0.6) {\n  decisionRationale.push(`Tono ${tone} tiene alto engagement histórico (${(toneConfidence * 100).toFixed(0)}%)`);\n  learningSources.push('PerformanceMemory');\n}\n\n// Factor 4: Evitar patrones fallidos (15%)\n// AUTO-AJUSTE: Penaliza automáticamente patrones fallidos y refuerza exitosos\nconst avoidPatterns = components.avoidPatterns || [];\nconst patternMemory = advancedMemory.patternMemory || {};\nconst successfulPatterns = patternMemory.successfulPatterns || [];\nconst blockedPatterns = patternMemory.blockedPatterns || [];\nlet patternViolations = 0;\nconst currentPattern = `${urgency}_${format}_${tone}`;\nconst isBlocked = blockedPatterns.some(blocked => currentPattern.includes(blocked) || blocked.includes(currentPattern));\n\nif (isBlocked) {\n  patternViolations = 1;\n  confidenceScore = 0; // Bloqueo total si está en lista de bloqueados\n  decisionRationale.push(`BLOQUEO: Patrón bloqueado temporalmente por fallos repetidos (30 días)`);\n  learningSources.push('PatternMemory');\n} else if (avoidPatterns.some(pattern => currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n  patternViolations = 1;\n  confidenceScore -= 0.2; // Penalización aumentada para patrones fallidos\n  decisionRationale.push(`ADVERTENCIA: Patrón similar a uno que ha fallado históricamente - PENALIZADO`);\n} else if (successfulPatterns.some(pattern => currentPattern.includes(pattern) || pattern.includes(currentPattern))) {\n  // Refuerzo para patrones exitosos\n  confidenceScore += 0.1;\n  decisionRationale.push(`Patrón identificado como exitoso históricamente - REFORZADO`);\n  learningSources.push('PatternMemory');\n} else {\n  confidenceScore += 0.05; // Patrón neutro\n  decisionRationale.push(`Patrón no está en lista de fallos históricos`);\n  learningSources.push('PatternMemory');\n}\n\n// Factor 5: Preferencias del tenant (10%)\nconst preferredFormats = components.preferredFormats || [];\nif (preferredFormats.includes(format)) {\n  confidenceScore += 0.1;\n  decisionRationale.push(`Formato ${format} está en preferencias del tenant`);\n  learningSources.push('PreferenceMemory');\n}\n\n// Factor 6: Restricciones cumplidas (5%)\nconst constraints = advancedMemory.constraintMemory?.restrictions || [];\nconst hasViolations = constraints.some(constraint => {\n  const channel = selectedChannels.find(c => constraint.toLowerCase().includes(c.toLowerCase()));\n  return channel !== undefined;\n});\nif (!hasViolations) {\n  confidenceScore += 0.05;\n  decisionRationale.push(`No se violan restricciones conocidas`);\n  learningSources.push('ConstraintMemory');\n} else {\n  confidenceScore -= 0.05;\n  decisionRationale.push(`ADVERTENCIA: Posible violación de restricciones`);\n}\n\n// Normalizar confidenceScore a 0-1\nconfidenceScore = Math.max(0, Math.min(1, confidenceScore));\n\n// Ajustar temperatura del modelo según confidence\n// Si confidence es bajo, usar temperatura más alta para más variación\n// Si confidence es alto, usar temperatura más baja para consistencia\nconst adaptiveTemperature = confidenceScore < 0.6 ? 0.8 : (confidenceScore > 0.8 ? 0.5 : 0.7);\n\n// Reducir variantes si confidence es bajo\nconst shouldReduceVariants = confidenceScore < 0.6;\n\n// Obtener cognitiveVersion REAL desde último MarketingPack o memoria\n// Se incrementa automáticamente cuando hay cambios significativos\nconst lastCognitiveVersion = components.lastCognitiveVersion || 1;\nlet cognitiveVersion = lastCognitiveVersion;\n\n// Si hay patrones fallidos recientes o cambios en priorización, incrementar versión\nconst recentFailedPatterns = patternMemory.failedPatterns || [];\nconst hasRecentFailures = recentFailedPatterns.length > 0;\nconst hasChannelPriorityChanges = performanceMemory.bestPerformingChannels && \n  performanceMemory.bestPerformingChannels.length > 0 &&\n  !selectedChannels.every(c => performanceMemory.bestPerformingChannels.includes(c));\n\n// Verificar si hay patrones exitosos nuevos que cambien priorización\nconst hasSuccessfulPatterns = successfulPatterns.length > 0 && \n  !successfulPatterns.every(sp => {\n    const patternStr = typeof sp === 'string' ? sp : (sp.pattern || JSON.stringify(sp));\n    return currentPattern.includes(patternStr) || patternStr.includes(currentPattern);\n  });\r\n\r\n// Incrementar versión cuando hay aprendizaje significativo\nif (hasRecentFailures || hasChannelPriorityChanges || hasSuccessfulPatterns || patternViolations > 0) {\n  cognitiveVersion = lastCognitiveVersion + 1;\n}\n\n// Decision rationale completo\nconst fullRationale = decisionRationale.join('; ');\n\n// Learning sources únicos\nconst uniqueLearningSources = [...new Set(learningSources)];\n\n// Obtener timestamp de forma segura\nlet calculatedAt = new Date().toISOString();\ntry {\n  const validatedNode = $('Set Validated Data');\n  if (validatedNode && validatedNode.item && validatedNode.item.json) {\n    calculatedAt = validatedNode.item.json.validatedData?.receivedAt || calculatedAt;\n  }\n} catch (e) {}\n\nresults.push({\n  json: {\n    ...components,\n    cognitiveDecision: {\n      confidenceScore: confidenceScore,\n      adaptiveTemperature: adaptiveTemperature,\n      shouldReduceVariants: shouldReduceVariants,\n      decisionRationale: fullRationale,\n      learningSources: uniqueLearningSources,\n      cognitiveVersion: cognitiveVersion,\n      channelConfidence: channelConfidence,\n      formatConfidence: formatConfidence,\n      toneConfidence: toneConfidence,\n      patternViolations: patternViolations,\n      calculatedAt: calculatedAt\n    }\n  }\n});\n  } catch (e) {\n    results.push({\n      json: {\n        ...item.json,\n        error: e.message,\n        cognitiveDecision: {\n          confidenceScore: 0.5,\n          adaptiveTemperature: 0.7,\n          shouldReduceVariants: false,\n          decisionRationale: 'Error en cálculo: ' + e.message,\n          learningSources: [],\n          cognitiveVersion: 1,\n          channelConfidence: 0.5,\n          formatConfidence: 0.5,\n          toneConfidence: 0.5,\n          patternViolations: 0,\n          calculatedAt: new Date().toISOString()\n        }\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "f4eb88cd-331b-4436-8863-5da616fe5145",
      "name": "Cognitive Decision Engine",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        224
      ]
    },
    {
      "parameters": {
        "jsCode": "// Función helper para generar UUID sin usar módulo crypto\nfunction generateUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n// Ensamblar el MarketingPack completo con campos cognitivos\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  try {\n    const components = item.json || {};\nconst strategy = components.strategy || {};\nconst copy = components.copy || {};\nconst visualPrompts = components.visualPrompts || {};\nconst media = Array.isArray(components.assets) ? components.assets : [];\nconst channels = Array.isArray(components.channels) ? components.channels : (strategy.channels || []);\n\n// Obtener tenantId y userId con fallbacks robustos\nfunction safeGetNodeData(nodeName) {\n  try {\n    const node = $(nodeName);\n    return node?.item?.json || {};\n  } catch (e) {\n    return {};\n  }\n}\n\nconst validatedData = safeGetNodeData('Set Validated Data');\nconst cognitiveVersionData = safeGetNodeData('Set Cognitive Engine Version');\n\nconst tenantId = components.tenantId || \n  validatedData.validatedData?.tenantId ||\n  cognitiveVersionData.tenantId ||\n  cognitiveVersionData.body?.body?.tenantId ||\n  '';\n\nconst userId = components.userId || \n  validatedData.validatedData?.userId ||\n  cognitiveVersionData.userId ||\n  cognitiveVersionData.body?.body?.userId ||\n  '';\n\nconst campaignId = components.campaignId || \n  validatedData.validatedData?.campaignId ||\n  cognitiveVersionData.campaignId ||\n  cognitiveVersionData.body?.body?.campaignId ||\n  null;\n\n// Validar que tenantId y userId no estén vacíos\nif (!tenantId || tenantId === '') {\n  throw new Error('tenantId is required but not found in workflow data');\n}\nif (!userId || userId === '') {\n  throw new Error('userId is required but not found in workflow data');\n}\n\n// Generar ID único para el pack\nconst packId = generateUUID();\n\n// Construir la estrategia como texto estructurado\nconst strategyText = JSON.stringify({\n  mainMessage: strategy.mainMessage || '',\n  cta: strategy.cta || '',\n  recommendedFormat: strategy.recommendedFormat || 'post',\n  tone: strategy.tone || 'profesional',\n  targetAudience: strategy.targetAudience || '',\n  keyPoints: strategy.keyPoints || [],\n  suggestedSchedule: strategy.suggestedSchedule || {},\n  contentStructure: strategy.contentStructure || {}\n}, null, 2);\n\n// Obtener contentId del payload original\n// Si no viene en el payload, generar uno nuevo (el backend lo creará automáticamente)\nconst contentId = components.contentId || \n  validatedData.validatedData?.contentId ||\n  cognitiveVersionData.body?.body?.contentId ||\n  cognitiveVersionData.contentId ||\n  generateUUID(); // Generar nuevo si no viene (el backend lo creará automáticamente)\n\n// Construir metadatos completos\nconst metadata = {\n  tenantId: tenantId,\n  userId: userId,\n  campaignId: campaignId,\n  contentId: contentId,\n  channels: channels,\n  requiresApproval: components.requiresApproval !== undefined ? components.requiresApproval : true,\n  generatedAt: new Date().toISOString(),\n  version: 1,\n  strategy: strategy,\n  copy: copy,\n  visualPrompts: visualPrompts,\n  media: media\n};\n\n// Construir GeneratedCopies desde el copy\nconst generatedCopies = [];\n\nif (copy.longCopy) {\n  generatedCopies.push({\n    id: generateUUID(),\n    copyType: 'long',\n    content: copy.longCopy,\n    hashtags: copy.hashtags ? copy.hashtags.join(', ') : null,\n    suggestedChannel: channels.length > 0 ? channels[0] : null,\n    publicationChecklist: {\n      hasCopy: true,\n      hasHashtags: (copy.hashtags || []).length > 0,\n      hasMedia: media.length > 0,\n      readyForPublication: true\n    }\n  });\n}\n\nif (copy.shortCopy) {\n  generatedCopies.push({\n    id: generateUUID(),\n    copyType: 'short',\n    content: copy.shortCopy,\n    hashtags: copy.hashtags ? copy.hashtags.join(', ') : null,\n    suggestedChannel: channels.length > 0 ? channels[0] : null,\n    publicationChecklist: {\n      hasCopy: true,\n      hasHashtags: (copy.hashtags || []).length > 0,\n      hasMedia: media.length > 0,\n      readyForPublication: true\n    }\n  });\n}\n\nif (copy.variants) {\n  if (copy.variants.variantA) {\n    generatedCopies.push({\n      id: generateUUID(),\n      copyType: 'variant-a',\n      content: copy.variants.variantA.longCopy || copy.variants.variantA.shortCopy || '',\n      hashtags: copy.variants.variantA.hashtags ? copy.variants.variantA.hashtags.join(', ') : null,\n      suggestedChannel: channels.length > 0 ? channels[0] : null,\n      publicationChecklist: {\n        hasCopy: true,\n        hasHashtags: (copy.variants.variantA.hashtags || []).length > 0,\n        isVariant: true,\n        variantType: 'A'\n      }\n    });\n  }\n  \n  if (copy.variants.variantB) {\n    generatedCopies.push({\n      id: generateUUID(),\n      copyType: 'variant-b',\n      content: copy.variants.variantB.longCopy || copy.variants.variantB.shortCopy || '',\n      hashtags: copy.variants.variantB.hashtags ? copy.variants.variantB.hashtags.join(', ') : null,\n      suggestedChannel: channels.length > 0 ? channels[0] : null,\n      publicationChecklist: {\n        hasCopy: true,\n        hasHashtags: (copy.variants.variantB.hashtags || []).length > 0,\n        isVariant: true,\n        variantType: 'B'\n      }\n    });\n  }\n}\n\n// Construir MarketingAssetPrompts desde visualPrompts\nconst assetPrompts = [];\n\nif (visualPrompts.imagePrompt) {\n  assetPrompts.push({\n    id: generateUUID(),\n    assetType: 'image',\n    prompt: visualPrompts.imagePrompt,\n    negativePrompt: null,\n    parameters: {\n      style: visualPrompts.imageStyle || 'professional',\n      aspectRatio: visualPrompts.aspectRatio || '1:1',\n      colorPalette: visualPrompts.colorPalette || [],\n      mood: visualPrompts.mood || 'professional',\n      ...(visualPrompts.technicalSpecs || {})\n    },\n    suggestedChannel: channels.length > 0 ? channels[0] : null\n  });\n}\n\nif (visualPrompts.videoPrompt) {\n  assetPrompts.push({\n    id: generateUUID(),\n    assetType: 'video',\n    prompt: visualPrompts.videoPrompt,\n    negativePrompt: null,\n    parameters: {\n      aspectRatio: visualPrompts.aspectRatio || '16:9',\n      colorPalette: visualPrompts.colorPalette || [],\n      mood: visualPrompts.mood || 'professional',\n      ...(visualPrompts.technicalSpecs || {})\n    },\n    suggestedChannel: channels.length > 0 ? channels[0] : null\n  });\n}\n\n// Obtener datos cognitivos del Decision Engine\nconst cognitiveDecision = components.cognitiveDecision || {};\nconst confidenceScore = cognitiveDecision.confidenceScore || 0.5;\nconst cognitiveVersion = cognitiveDecision.cognitiveVersion || 1;\nconst decisionRationale = cognitiveDecision.decisionRationale || '';\nconst learningSources = cognitiveDecision.learningSources || [];\n\n// Construir el MarketingPack final con campos cognitivos\nconst marketingPack = {\n  id: packId,\n  tenantId: tenantId,\n  userId: userId,\n  contentId: contentId,\n  campaignId: campaignId,\n  strategy: strategyText,\n  status: components.requiresApproval ? 'Generated' : 'Ready',\n  version: 1,\n  metadata: JSON.stringify(metadata),\n  copies: generatedCopies,\n  assetPrompts: assetPrompts,\n  channels: channels,\n  media: media,\n  requiresApproval: components.requiresApproval !== undefined ? components.requiresApproval : true,\n  createdAt: new Date().toISOString(),\n  cognitiveVersion: cognitiveVersion,\n  confidenceScore: confidenceScore,\n  learningSources: learningSources,\n  decisionRationale: decisionRationale\n};\n\nresults.push({\n  json: {\n    ...components,\n    marketingPack: marketingPack,\n    cognitiveDecision: cognitiveDecision\n  }\n});\n  } catch (e) {\n    results.push({\n      json: {\n        ...item.json,\n        error: e.message,\n        marketingPack: null,\n        cognitiveDecision: null\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "8ce8b356-e3d5-49ba-a735-48df46a5712b",
      "name": "Build Marketing Pack",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        224
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.marketingPack.confidenceScore ?? $json.cognitiveDecision?.confidenceScore ?? 0.5 }}",
              "rightValue": 0.6,
              "operator": {
                "type": "number",
                "operation": "smaller"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "20bb6c97-ea16-4511-8b58-d306b98326f5",
      "name": "Validate Confidence Score",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1120,
        224
      ]
    },
    {
      "parameters": {
        "jsCode": "// Registrar Override Humano cuando confidenceScore < 0.6 pero requiresApproval = false\nconst components = $input.item.json;\nconst marketingPack = components.marketingPack || {};\nconst cognitiveDecision = components.cognitiveDecision || {};\nconst strategy = components.strategy || {};\nconst validatedData = $('Set Validated Data').item?.json?.validatedData || {};\n\nconst confidenceScore = marketingPack.confidenceScore ?? cognitiveDecision?.confidenceScore ?? 0.5;\nconst requiresApproval = marketingPack.requiresApproval ?? components.requiresApproval ?? true;\n\n// Detectar override: confidenceScore < 0.6 pero requiresApproval = false\nconst isOverride = confidenceScore < 0.6 && requiresApproval === false;\n\nif (isOverride) {\n  // Extraer datos del patrón\n  const urgency = components.analysis?.urgency || 'medium';\n  const format = strategy.recommendedFormat || 'post';\n  const tone = strategy.tone || 'profesional';\n  const channels = Array.isArray(strategy.channels) ? strategy.channels : [];\n  const pattern = `${urgency}_${format}_${tone}`;\n  \n  // Obtener overrideReason del payload si existe\n  const overrideReason = components.overrideReason || components.overrideSource || 'unknown';\n  const overrideSource = components.overrideSource || 'unknown';\n  \n  // Usar timestamp determinístico del validatedData\n  const timestamp = validatedData.receivedAt || new Date().toISOString();\n  const requestId = validatedData.requestId || 'unknown';\n  \n  // Crear overrideData estructurado\n  const overrideData = {\n    pattern: pattern,\n    result: 'override',\n    overrideType: 'human_forced_publication',\n    originalConfidenceScore: Math.round(confidenceScore * 10000) / 10000,\n    humanDecision: 'force_publication',\n    overrideReason: overrideReason,\n    overrideSource: overrideSource,\n    context: {\n      channels: channels,\n      format: format,\n      tone: tone,\n      urgency: urgency,\n      campaignId: components.campaignId || null,\n      marketingPackId: marketingPack.id || null\n    },\n    timestamp: timestamp,\n    requestId: requestId,\n    userId: components.userId || validatedData.userId || 'unknown',\n    decisionRationale: cognitiveDecision.decisionRationale || ''\n  };\n  \n  return {\n    ...components,\n    humanOverride: overrideData,\n    hasOverride: true\n  };\n}\n\n// Sin override, pasar datos sin cambios\nreturn {\n  ...components,\n  hasOverride: false\n};"
      },
      "id": "b87b7ed7-e3c7-4697-8dcd-009d7516b4f1",
      "name": "Register Human Override",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        576
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/MemoryApi/save",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ (() => { const components = $json; const humanOverride = components.humanOverride || {}; const marketingPack = components.marketingPack || {}; const validatedData = $('Set Validated Data').item?.json?.validatedData || {}; return { tenantId: marketingPack.tenantId || validatedData.tenantId || components.tenantId || '', userId: marketingPack.userId || validatedData.userId || components.userId || '', campaignId: marketingPack.campaignId || validatedData.campaignId || components.campaignId || null, memoryType: 'Pattern', content: JSON.stringify(humanOverride || {}), context: humanOverride.context || {}, tags: humanOverride.tags || ['pattern', 'override', 'human_forced_publication'], relevanceScore: 8 }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "d8349404-8726-44b4-8213-4ac83b82572c",
      "name": "HTTP Request - Save Override Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        192,
        576
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.marketingPack.requiresApproval ?? $json.requiresApproval ?? true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "bcff43fb-d1fa-415e-a69e-cd2807731d95",
      "name": "Check Requires Approval Final",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -208,
        864
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ (() => { function safeGetNodeData(nodeName) { try { const node = $(nodeName); return node?.item?.json || {}; } catch (e) { return {}; } } const mp = $json.marketingPack || {}; if (!mp || Object.keys(mp).length === 0) { throw new Error('marketingPack is required but not found in the workflow data'); } const validatedData = safeGetNodeData('Set Validated Data'); const cognitiveVersionData = safeGetNodeData('Set Cognitive Engine Version'); const tenantId = String(mp.tenantId || validatedData.validatedData?.tenantId || cognitiveVersionData.body?.body?.tenantId || cognitiveVersionData.tenantId || '').trim(); const userId = String(mp.userId || validatedData.validatedData?.userId || cognitiveVersionData.body?.body?.userId || cognitiveVersionData.userId || '').trim(); const contentId = String(mp.contentId || '').trim(); if (!tenantId || tenantId === '' || tenantId === 'undefined' || tenantId === 'null' || tenantId === '00000000-0000-0000-0000-000000000000') { throw new Error('tenantId is required and must be a valid GUID. Found: ' + JSON.stringify(tenantId)); } if (!userId || userId === '' || userId === 'undefined' || userId === 'null' || userId === '00000000-0000-0000-0000-000000000000') { throw new Error('userId is required and must be a valid GUID. Found: ' + JSON.stringify(userId)); } if (!contentId || contentId === '' || contentId === 'undefined' || contentId === 'null' || contentId === '00000000-0000-0000-0000-000000000000') { throw new Error('contentId is required and must be a valid GUID. Found: ' + JSON.stringify(contentId)); } return { id: mp.id || null, tenantId: tenantId, userId: userId, contentId: contentId, campaignId: mp.campaignId || null, strategy: mp.strategy || '', status: mp.status || 'Generated', version: mp.version || 1, metadata: mp.metadata || null, copies: (mp.copies || []).map(c => ({ id: c.id || null, copyType: c.copyType || '', content: c.content || '', hashtags: c.hashtags || null, suggestedChannel: c.suggestedChannel || null, publicationChecklist: c.publicationChecklist || null })), assetPrompts: (mp.assetPrompts || []).map(a => ({ id: a.id || null, assetType: a.assetType || '', prompt: a.prompt || '', negativePrompt: a.negativePrompt || null, parameters: a.parameters || null, suggestedChannel: a.suggestedChannel || null })) }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "8b645546-c7bc-45ea-b354-5ccbe874974b",
      "name": "HTTP Request - Save Pack (Requires Approval)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        288,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/marketing-packs",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ (() => { function safeGetNodeData(nodeName) { try { const node = $(nodeName); return node?.item?.json || {}; } catch (e) { return {}; } } const mp = $json.marketingPack || {}; if (!mp || Object.keys(mp).length === 0) { throw new Error('marketingPack is required but not found. Available keys in $json: ' + Object.keys($json || {}).join(', ')); } const validatedData = safeGetNodeData('Set Validated Data'); const cognitiveVersionData = safeGetNodeData('Set Cognitive Engine Version'); const tenantId = String(mp.tenantId || validatedData.validatedData?.tenantId || cognitiveVersionData.body?.body?.tenantId || cognitiveVersionData.tenantId || '').trim(); const userId = String(mp.userId || validatedData.validatedData?.userId || cognitiveVersionData.body?.body?.userId || cognitiveVersionData.userId || '').trim(); const contentId = String(mp.contentId || '').trim(); if (!tenantId || tenantId === '' || tenantId === 'undefined' || tenantId === 'null' || tenantId === '00000000-0000-0000-0000-000000000000') { throw new Error('tenantId is required and must be a valid GUID. Found: ' + JSON.stringify(tenantId) + ', marketingPack keys: ' + Object.keys(mp).join(', ')); } if (!userId || userId === '' || userId === 'undefined' || userId === 'null' || userId === '00000000-0000-0000-0000-000000000000') { throw new Error('userId is required and must be a valid GUID. Found: ' + JSON.stringify(userId)); } if (!contentId || contentId === '' || contentId === 'undefined' || contentId === 'null' || contentId === '00000000-0000-0000-0000-000000000000') { throw new Error('contentId is required and must be a valid GUID. Found: ' + JSON.stringify(contentId)); } return { id: mp.id || null, tenantId: tenantId, userId: userId, contentId: contentId, campaignId: mp.campaignId || null, strategy: mp.strategy || '', status: mp.status || 'Ready', version: mp.version || 1, metadata: mp.metadata || null, copies: (mp.copies || []).map(c => ({ id: c.id || null, copyType: c.copyType || '', content: c.content || '', hashtags: c.hashtags || null, suggestedChannel: c.suggestedChannel || null, publicationChecklist: c.publicationChecklist || null })), assetPrompts: (mp.assetPrompts || []).map(a => ({ id: a.id || null, assetType: a.assetType || '', prompt: a.prompt || '', negativePrompt: a.negativePrompt || null, parameters: a.parameters || null, suggestedChannel: a.suggestedChannel || null })) }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "7e4a4a1d-015e-462d-95a2-c532ba6c69a5",
      "name": "HTTP Request - Save Pack (Ready)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -144,
        1088
      ]
    },
    {
      "parameters": {
        "jsCode": "// Preparar datos para publicación en cada canal\nconst marketingPack = $input.item.json.marketingPack;\nconst copy = $input.item.json.copy || {};\nconst channels = Array.isArray(marketingPack.channels) ? marketingPack.channels : [];\nconst publishJobs = [];\n\n// Para cada canal, crear un job de publicación\nchannels.forEach(channel => {\n  const channelCopy = copy.publishFormat?.[channel.toLowerCase()] || copy.longCopy || '';\n  const hashtags = copy.hashtags || [];\n  const hashtagsString = hashtags.map(h => '#' + h.replace(/^#/, '')).join(' ');\n  \n  publishJobs.push({\n    channel: channel.toLowerCase(),\n    content: channelCopy,\n    hashtags: hashtagsString,\n    mediaUrl: marketingPack.media && marketingPack.media.length > 0 ? marketingPack.media[0] : null,\n    tenantId: marketingPack.tenantId,\n    campaignId: marketingPack.campaignId,\n    marketingPackId: marketingPack.id,\n    generatedCopyId: marketingPack.copies && marketingPack.copies.length > 0 ? marketingPack.copies[0].id : null\n  });\n});\n\nreturn publishJobs.map(job => ({ json: { ...$input.item.json, ...job } }));"
      },
      "id": "750695d6-b9fe-460a-9d38-e5bd4d8c77a2",
      "name": "Prepare Publish Jobs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        192,
        784
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "instagram",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "2f204575-249c-443b-85ef-431064b764c4",
      "name": "Check - Instagram",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        400,
        688
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "facebook",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "12f8fd95-6d70-430d-9533-5a420267678b",
      "name": "Check - Facebook",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        400,
        784
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.channel.toLowerCase() }}",
              "rightValue": "tiktok",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "80f819d1-67ce-4c57-b2b5-f66379996e13",
      "name": "Check - TikTok",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        400,
        896
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.INSTAGRAM_API_URL || 'https://api.instagram.com/v1/media' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {}
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "9bca2336-ccd0-4510-891d-e297f31ccefe",
      "name": "Publish - Instagram",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        592,
        576
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.FACEBOOK_API_URL || 'https://graph.facebook.com/v18.0/me/feed' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {}
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "65432f0e-f487-41ee-8c1e-02b91e414100",
      "name": "Publish - Facebook",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        592,
        784
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.TIKTOK_API_URL || 'https://open-api.tiktok.com/video/upload' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Publish-Data",
              "value": "={{ JSON.stringify({ channel: $json.channel, content: $json.content, hashtags: $json.hashtags, mediaUrl: $json.mediaUrl, tenantId: $json.tenantId, campaignId: $json.campaignId, marketingPackId: $json.marketingPackId, generatedCopyId: $json.generatedCopyId }) }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {}
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "1b24385f-353b-4501-bd3f-360948dff663",
      "name": "Publish - TikTok",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        592,
        896
      ]
    },
    {
      "parameters": {
        "jsCode": "// Procesar resultado de publicación (real o simulado)\nconst input = $input.item.json;\n// Intentar obtener datos del item anterior usando el contexto de n8n\nlet publishData = {};\ntry {\n  // Intentar obtener del nodo anterior (Prepare Publish Jobs)\n  const previousNode = $('Prepare Publish Jobs');\n  if (previousNode && previousNode.item) {\n    publishData = previousNode.item.json;\n  }\n} catch (e) {\n  // Si falla, usar datos del input actual\n  publishData = input;\n}\n\n// Si el input tiene los datos directamente (viene de Check - Instagram/Facebook/TikTok cuando no coincide)\nconst channel = input.channel || publishData.channel || '';\nconst content = input.content || publishData.content || '';\nconst hashtags = input.hashtags || publishData.hashtags || '';\nconst mediaUrl = input.mediaUrl || publishData.mediaUrl || null;\nconst tenantId = input.tenantId || publishData.tenantId || '';\nconst campaignId = input.campaignId || publishData.campaignId || null;\nconst marketingPackId = input.marketingPackId || publishData.marketingPackId || null;\nconst generatedCopyId = input.generatedCopyId || publishData.generatedCopyId || null;\n\nconst isSimulated = !input.id && !input.post_id && !input.data && !input.success;\nconst hasError = input.error || input.error_code || (input.statusCode && input.statusCode >= 400);\n\nif (hasError || isSimulated) {\n  const simulatedResponse = {\n    success: true,\n    simulated: true,\n    channel: channel.toLowerCase(),\n    postId: `sim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    publishedUrl: `https://${channel.toLowerCase()}.com/posts/sim_${Date.now()}`,\n    publishedAt: new Date().toISOString(),\n    message: `Publication simulated for ${channel} (no credentials configured)`,\n    content: content,\n    hashtags: hashtags,\n    mediaUrl: mediaUrl,\n    tenantId: tenantId,\n    campaignId: campaignId,\n    marketingPackId: marketingPackId,\n    generatedCopyId: generatedCopyId\n  };\n  \n  return simulatedResponse;\n} else {\n  const realResponse = {\n    success: true,\n    simulated: false,\n    channel: channel.toLowerCase(),\n    postId: input.id || input.post_id || input.data?.id || `real_${Date.now()}`,\n    publishedUrl: input.permalink_url || input.link || input.data?.url || `https://${channel.toLowerCase()}.com/posts/${input.id || input.post_id}`,\n    publishedAt: new Date().toISOString(),\n    message: `Successfully published to ${channel}`,\n    content: content,\n    hashtags: hashtags,\n    mediaUrl: mediaUrl,\n    tenantId: tenantId,\n    campaignId: campaignId,\n    marketingPackId: marketingPackId,\n    generatedCopyId: generatedCopyId\n  };\n  \n  return realResponse;\n}"
      },
      "id": "7b3bda07-6379-414b-b8a7-80250b830f8f",
      "name": "Process Publish Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        688
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/publishing-jobs",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ (() => { const campaignId = $json.campaignId || $('Prepare Publish Jobs').item.json.campaignId || $('Build Marketing Pack').item.json.marketingPack?.campaignId || '00000000-0000-0000-0000-000000000000'; if (!campaignId || campaignId === '00000000-0000-0000-0000-000000000000') { throw new Error('campaignId is required but not found in workflow data'); } return { tenantId: $json.tenantId || $('Prepare Publish Jobs').item.json.tenantId || $('Build Marketing Pack').item.json.marketingPack?.tenantId || '', campaignId: campaignId, marketingPackId: $json.marketingPackId || $('Prepare Publish Jobs').item.json.marketingPackId || null, generatedCopyId: $json.generatedCopyId || $('Prepare Publish Jobs').item.json.generatedCopyId || null, channel: $json.channel || '', status: $json.success === false ? 'Failed' : ($json.simulated === true ? 'Simulated' : 'Success'), publishedDate: $json.publishedAt || new Date().toISOString(), publishedUrl: $json.publishedUrl || null, externalPostId: $json.postId || null, content: $json.content || '', hashtags: $json.hashtags || null, mediaUrl: $json.mediaUrl || null, errorMessage: $json.error || null }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "f12a6d0a-4ff9-4fac-ad7c-ae0b35245a0c",
      "name": "HTTP Request - Save Publishing Job",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        992,
        688
      ]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar todos los resultados de publicación\nconst allResults = $input.all();\nconst firstResult = allResults[0] || {};\n\n// Obtener todos los publishing jobs guardados (vienen del HTTP Request - Save Publishing Job)\nconst publishingJobs = allResults\n  .filter(r => r.json.id && (r.json.channel || r.json.tenantId))\n  .map(r => ({\n    id: r.json.id,\n    channel: r.json.channel || 'unknown',\n    status: r.json.status || 'Success',\n    publishedUrl: r.json.publishedUrl || null\n  }));\n\n// Si no hay jobs, intentar obtener datos del primer resultado\nconst tenantId = firstResult.json.tenantId || '';\nconst campaignId = firstResult.json.campaignId || null;\nconst marketingPackId = firstResult.json.marketingPackId || null;\n\nreturn {\n  tenantId: tenantId,\n  campaignId: campaignId,\n  marketingPackId: marketingPackId,\n  publishingJobIds: publishingJobs.map(j => j.id).filter(id => id),\n  publishingJobs: publishingJobs,\n  channels: publishingJobs.map(j => j.channel).filter(c => c),\n  allPublished: publishingJobs.length > 0 && publishingJobs.every(j => j.status === 'Success'),\n  success: true\n};"
      },
      "id": "cb962668-78a5-4907-93f1-e42270e79c2f",
      "name": "Consolidate Publish Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        688
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/metrics/campaign",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ (() => { const tenantId = $json.tenantId || $('Consolidate Publish Results').item.json.tenantId || $('Build Marketing Pack').item.json.marketingPack?.tenantId || ''; const campaignId = $json.campaignId || $('Consolidate Publish Results').item.json.campaignId || $('Build Marketing Pack').item.json.marketingPack?.campaignId || '00000000-0000-0000-0000-000000000000'; if (!tenantId || tenantId === '') { throw new Error('tenantId is required but not found in workflow data'); } if (!campaignId || campaignId === '00000000-0000-0000-0000-000000000000') { throw new Error('campaignId is required but not found in workflow data'); } return { tenantId: tenantId, campaignId: campaignId, metricDate: new Date().toISOString().split('T')[0], impressions: 0, clicks: 0, likes: 0, comments: 0, shares: 0, source: 'n8n', notes: 'Initial metrics created after publishing jobs' }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "613a879a-7b69-41a0-9fba-20e30960172e",
      "name": "HTTP Request - Save Campaign Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1392,
        576
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/metrics/publishing-job",
        "sendBody": true,
        "contentType": "json",
        "body": "={{ (() => { const consolidateData = $('Consolidate Publish Results').item.json; const publishingJobIds = consolidateData.publishingJobIds || []; const tenantId = consolidateData.tenantId || $('Build Marketing Pack').item.json.marketingPack?.tenantId || ''; if (!tenantId || tenantId === '') { throw new Error('tenantId is required but not found in workflow data'); } if (publishingJobIds.length === 0) { return { tenantId: tenantId, publishingJobId: '00000000-0000-0000-0000-000000000000', metricDate: new Date().toISOString().split('T')[0], impressions: 0, clicks: 0, likes: 0, comments: 0, shares: 0, source: 'n8n', notes: 'No publishing jobs to track' }; } return { tenantId: tenantId, publishingJobId: publishingJobIds[0], metricDate: new Date().toISOString().split('T')[0], impressions: 0, clicks: 0, likes: 0, comments: 0, shares: 0, source: 'n8n', notes: 'Initial metrics created after publishing' }; })() }}",
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "7ebac3f8-1172-460b-8274-2fb3bf68370d",
      "name": "HTTP Request - Save Job Metrics",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1392,
        688
      ]
    },
    {
      "parameters": {
        "jsCode": "// Consolidar resultados finales\nconst results = $input.all();\nconst consolidateData = $('Consolidate Publish Results').item.json;\n\nconst metricsResult = results.find(r => r.json.id && r.json.campaignId) || null;\nconst jobMetricsResult = results.find(r => r.json.publishingJobId) || null;\n\nreturn {\n  tenantId: consolidateData.tenantId,\n  campaignId: consolidateData.campaignId,\n  marketingPackId: consolidateData.marketingPackId,\n  publishingJobIds: consolidateData.publishingJobIds,\n  publishingJobs: consolidateData.publishingJobs,\n  channels: consolidateData.channels,\n  metricsSaved: metricsResult !== null,\n  jobMetricsSaved: jobMetricsResult !== null,\n  metricsId: metricsResult?.json.id || null,\n  jobMetricsId: jobMetricsResult?.json.id || null,\n  success: true,\n  message: 'Complete marketing flow executed successfully'\n};"
      },
      "id": "c67ec767-0f57-4508-8d3a-42c366a02d4e",
      "name": "Consolidate Final Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        688
      ]
    },
    {
      "parameters": {
        "url": "={{ ($env.BACKEND_URL && $env.BACKEND_URL !== 'http://localhost:5000') ? $env.BACKEND_URL : 'https://autonomousmarketingplatform.onrender.com' }}/api/Memory/context",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "tenantId",
              "value": "={{ $('Set Cognitive Engine Version').item.json.body.body.tenantId }}"
            },
            {
              "name": "memoryType",
              "value": "Feedback"
            }
          ]
        },
        "options": {
          "timeout": 300000,
          "continueOnFail": true,
          "retryOnFail": true,
          "maxRetries": 3
        }
      },
      "id": "18ac9ef6-b098-4d22-8797-1f5191b006f5",
      "name": "HTTP Request - Load Constraint Memory",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -592,
        672
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Receive Request": {
      "main": [
        [
          {
            "node": "Normalize Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Payload": {
      "main": [
        [
          {
            "node": "Validate Required Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Required Fields": {
      "main": [
        [
          {
            "node": "Set Validated Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Validated Data": {
      "main": [
        [
          {
            "node": "Set Cognitive Engine Version",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Cognitive Engine Version": {
      "main": [
        [
          {
            "node": "HTTP Request - Check Consents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Check Consents": {
      "main": [
        [
          {
            "node": "Normalize Consents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Consents": {
      "main": [
        [
          {
            "node": "Validate Consents",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Consents": {
      "main": [
        [
          {
            "node": "HTTP Request - Load Marketing Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Load Marketing Memory": {
      "main": [
        [
          {
            "node": "Normalize Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Memory": {
      "main": [
        [
          {
            "node": "HTTP Request - Load Preference Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request - Load Performance Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request - Load Pattern Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request - Get Last Cognitive Version",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request - Load Constraint Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Load Preference Memory": {
      "main": [
        [
          {
            "node": "Consolidate Advanced Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Load Performance Memory": {
      "main": [
        [
          {
            "node": "Consolidate Advanced Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Load Pattern Memory": {
      "main": [
        [
          {
            "node": "Consolidate Advanced Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Get Last Cognitive Version": {
      "main": [
        [
          {
            "node": "Consolidate Advanced Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consolidate Advanced Memory": {
      "main": [
        [
          {
            "node": "OpenAI - Analyze Instruction (Cognitive)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Analyze Instruction (Cognitive)": {
      "main": [
        [
          {
            "node": "Parse Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Analysis": {
      "main": [
        [
          {
            "node": "OpenAI - Generate Strategy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Generate Strategy": {
      "main": [
        [
          {
            "node": "Parse Strategy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Strategy": {
      "main": [
        [
          {
            "node": "OpenAI - Generate Copy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Generate Copy": {
      "main": [
        [
          {
            "node": "Parse Copy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Copy": {
      "main": [
        [
          {
            "node": "OpenAI - Generate Visual Prompts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Generate Visual Prompts": {
      "main": [
        [
          {
            "node": "Parse Visual Prompts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Visual Prompts": {
      "main": [
        [
          {
            "node": "Cognitive Decision Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cognitive Decision Engine": {
      "main": [
        [
          {
            "node": "Build Marketing Pack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Marketing Pack": {
      "main": [
        [
          {
            "node": "Validate Confidence Score",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Confidence Score": {
      "main": [
        [
          {
            "node": "Register Human Override",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check Requires Approval Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Register Human Override": {
      "main": [
        [
          {
            "node": "HTTP Request - Save Override Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check Requires Approval Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Save Override Memory": {
      "main": [
        [
          {
            "node": "Check Requires Approval Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Requires Approval Final": {
      "main": [
        [
          {
            "node": "HTTP Request - Save Pack (Requires Approval)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request - Save Pack (Ready)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Save Pack (Requires Approval)": {
      "main": [
        []
      ]
    },
    "HTTP Request - Save Pack (Ready)": {
      "main": [
        [
          {
            "node": "Prepare Publish Jobs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Publish Jobs": {
      "main": [
        [
          {
            "node": "Check - Instagram",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check - Facebook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check - TikTok",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check - Instagram": {
      "main": [
        [
          {
            "node": "Publish - Instagram",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check - Facebook": {
      "main": [
        [
          {
            "node": "Publish - Facebook",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check - TikTok": {
      "main": [
        [
          {
            "node": "Publish - TikTok",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Publish - Instagram": {
      "main": [
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Publish - Facebook": {
      "main": [
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Publish - TikTok": {
      "main": [
        [
          {
            "node": "Process Publish Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Publish Result": {
      "main": [
        [
          {
            "node": "HTTP Request - Save Publishing Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Save Publishing Job": {
      "main": [
        [
          {
            "node": "Consolidate Publish Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consolidate Publish Results": {
      "main": [
        [
          {
            "node": "HTTP Request - Save Campaign Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Save Campaign Metrics": {
      "main": [
        [
          {
            "node": "Consolidate Final Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request - Save Job Metrics": {
      "main": [
        [
          {
            "node": "Consolidate Final Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Consolidate Final Results": {
      "main": [
        []
      ]
    },
    "HTTP Request - Load Constraint Memory": {
      "main": [
        [
          {
            "node": "Consolidate Advanced Memory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "4f51d63f-13a9-4974-a6ad-4914c7e8293e",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "4856b50c573e21e6444e6cfbe31d68cbd351a64a6dfd678ed9d49fed40a66d4a"
  },
  "id": "w5DYOoa0PeWcTepQ",
  "tags": [
    {
      "updatedAt": "2026-01-03T02:51:13.513Z",
      "createdAt": "2026-01-03T02:51:13.513Z",
      "id": "6YnFt6ZJU96R3bJn",
      "name": "Feedback Loop"
    },
    {
      "updatedAt": "2025-12-30T14:37:04.786Z",
      "createdAt": "2025-12-30T14:37:04.786Z",
      "id": "FvrACFYopEDXTtxM",
      "name": "Trigger"
    },
    {
      "updatedAt": "2025-12-30T14:37:04.765Z",
      "createdAt": "2025-12-30T14:37:04.765Z",
      "id": "JfnZMQSUzWNavfeb",
      "name": "Marketing Automation"
    },
    {
      "updatedAt": "2026-01-03T00:43:11.496Z",
      "createdAt": "2026-01-03T00:43:11.496Z",
      "id": "qIZKeafnm0uts6oj",
      "name": "Memory"
    },
    {
      "updatedAt": "2026-01-03T01:12:46.850Z",
      "createdAt": "2026-01-03T01:12:46.850Z",
      "id": "xfr3BmyeGEy8SFaa",
      "name": "Complete Flow"
    },
    {
      "updatedAt": "2026-01-03T02:51:13.533Z",
      "createdAt": "2026-01-03T02:51:13.533Z",
      "id": "yMqAUR4wk8sgbBJ8",
      "name": "Learning"
    }
  ]
}